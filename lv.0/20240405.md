# ë°°ì—´ì˜ ìœ ì‚¬ë„

ë¬¸ì œ ì„¤ëª…
- ë‘ ë°°ì—´ì´ ì–¼ë§ˆë‚˜ ìœ ì‚¬í•œì§€ í™•ì¸í•´ë³´ë ¤ê³  í•©ë‹ˆë‹¤. ë¬¸ìì—´ ë°°ì—´ s1ê³¼ s2ê°€ ì£¼ì–´ì§ˆ ë•Œ ê°™ì€ ì›ì†Œì˜ ê°œìˆ˜ë¥¼ returní•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.

ì œí•œì‚¬í•­
- 1 â‰¤ s1, s2ì˜ ê¸¸ì´ â‰¤ 100
- 1 â‰¤ s1, s2ì˜ ì›ì†Œì˜ ê¸¸ì´ â‰¤ 10
- s1ê³¼ s2ì˜ ì›ì†ŒëŠ” ì•ŒíŒŒë²³ ì†Œë¬¸ìë¡œë§Œ ì´ë£¨ì–´ì ¸ ìˆìŠµë‹ˆë‹¤
- s1ê³¼ s2ëŠ” ê°ê° ì¤‘ë³µëœ ì›ì†Œë¥¼ ê°–ì§€ ì•ŠìŠµë‹ˆë‹¤.

ì…ì¶œë ¥ ì˜ˆ
- s1	s2	result
- ["a", "b", "c"]	["com", "b", "d", "p", "c"]	2
- ["n", "omg"]	["m", "dot"]	0

ì…ì¶œë ¥ ì˜ˆ ì„¤ëª…
ì…ì¶œë ¥ ì˜ˆ #1 <br>
- "b"ì™€ "c"ê°€ ê°™ìœ¼ë¯€ë¡œ 2ë¥¼ returní•©ë‹ˆë‹¤.

ì…ì¶œë ¥ ì˜ˆ #2 <br>
- ê°™ì€ ì›ì†Œê°€ ì—†ìœ¼ë¯€ë¡œ 0ì„ returní•©ë‹ˆë‹¤.

```
function solution(s1, s2) {
   return s1.filter((n) => s2.includes(n)).length
}
```
ì´ê±´ ì§„ì§œ ë³´ìë§ˆì í•œ ë²ˆì— í’€ê³  í•œ ë²ˆì— ë§ì·„ë‹¤,,,! ì´ëŸ´ ë•ŒëŠ” ë¿Œë“¯í•œë°ã… ì–´ë ¤ìš´ ë¬¸ì œë„ ì´ë¬ìœ¼ë©´...ğŸ¥¹

# ë¦¬ë””ì•„ í• ë¦¬ 5ë²ˆ
```
const bird = {
  size: 'small',
};

const mouse = {
  name: 'Mickey',
  small: true,
};
```
- A: mouse.bird.size ëŠ” ìœ íš¨í•˜ì§€ ì•Šì•„ìš”
- B: mouse[bird.size] ëŠ” ìœ íš¨í•˜ì§€ ì•Šì•„ìš”
- C: mouse[bird['size']] ëŠ” ìœ íš¨í•˜ì§€ ì•Šì•„ìš”
- D: ì´ ëª¨ë“  ê²ƒì€ ìœ íš¨í•´ìš”.
ë‹µ: A
JavaScriptì—ì„œ ëª¨ë“  ê°ì²´ì˜ í‚¤ëŠ” ë¬¸ìì—´ì´ì—ìš”(ì‹¬ë³¼ì´ ì•„ë‹Œ í•œ). ê°ì²´ì˜ í‚¤ë¥¼ ë¬¸ìì—´ í˜• ìœ¼ë¡œ ì…ë ¥í•˜ì§€ ì•Šë”ë¼ë„, í•­ìƒ ë‚´ë¶€ì ìœ¼ë¡œ ë¬¸ìì—´ë¡œ ë³€í™˜ë¼ìš”.<br>
In JavaScript, all object keys are strings (unless it's a Symbol). Even though we might not type them as strings, they are always converted into strings under the hood.

JavaScriptëŠ” ë¬¸ì¥ì„ í•´ì„(ë˜ëŠ” ë¶„)í•´ìš”. ëŒ€ê´„í˜¸ í‘œê¸°ë¥¼ ì‚¬ìš©í•˜ë©´ ì²« ë²ˆì§¸ ì—´ë¦° ëŒ€ê´„í˜¸ [ë¥¼ ë³´ê³  ë‹«íŒ ëŒ€ê´„í˜¸ ]ë¥¼ ì°¾ì„ ë•Œê¹Œì§€ ì§„í–‰í•´ìš”. ë‹¤ ì°¾ì€ í›„ì—ë§Œ ë¬¸ì¥ì„ í‰ê°€í•  ê±°ì˜ˆìš”.<br>
JavaScript interprets (or unboxes) statements. When we use bracket notation, it sees the first opening bracket [ and keeps going until it finds the closing bracket ]. Only then, it will evaluate the statement.

mouse[bird.size]: ë¨¼ì € 'small'ì¸ bird.sizeë¥¼ í‰ê°€í•´ìš”. mouse['small'] ì€ trueë¥¼ ë°˜í™˜í•´ìš”.<br>
mouse[bird.size]: First it evaluates bird.size, which is "small". mouse["small"] returns true

ê·¸ëŸ¬ë‚˜ ì´ê²ƒì€ ì  í‘œê¸°ë²•ì—ì„œ ë°œìƒí•˜ì§€ ì•Šì•„ìš”. mouseê°€ birdë¼ê³  ë¶ˆë¦¬ëŠ” í‚¤ë¥¼ ê°€ì§€ê³  ìˆì§€ ì•Šê¸° ë•Œë¬¸ì—, mouse.birdëŠ” undefinedì„ì„ ì˜ë¯¸í•´ìš”. ê·¸ë‹¤ìŒì—, ì  í‘œê¸°ë²•ì„ ì‚¬ìš©í•´ sizeë¥¼ ë¬¼ì–´ë´ìš”: mouse.bird.size. mouse.birdëŠ” undefinedì´ê¸° ë•Œë¬¸ì—, ì‚¬ì‹¤ ìš°ë¦¬ê°€ ë¬¼ì–´ë³´ëŠ” ê±´ undefined.sizeì—ìš”. ì´ê±´ ìœ íš¨í•˜ì§€ ì•Šì•„ìš”, ê·¸ë¦¬ê³  Cannot read property 'size' of undefinedì™€ ë¹„ìŠ·í•œ ì˜¤ë¥˜ë¥¼ ë˜ì§ˆ ê±°ì˜ˆìš”.<br>
However, with dot notation, this doesn't happen. mouse does not have a key called bird, which means that mouse.bird is undefined. Then, we ask for the size using dot notation: mouse.bird.size. Since mouse.bird is undefined, we're actually asking undefined.size. This isn't valid, and will throw an error similar to Cannot read property "size" of undefined.

ë­ë¼ëŠ”ê±°ì•¼ ì§„ì§œë¡œ...
